var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EventBucket_instances, _EventBucket_eventOverlapping;
import { endOfMonth, endOfWeek, startOfMonth, startOfWeek } from 'date-fns/esm';
import { differenceInMilliseconds } from 'date-fns';
/**
 * Calculates start and end dates of month in a calendar.
 * @param date Context date for which range need to calculated.
 * @param weekStartsOn A numeric value. The index of the first day of the week (0 - Sunday)
 */
export function calculateMonthRange(date, weekStartsOn = 1) {
  const startDate = startOfWeek(startOfMonth(date), { weekStartsOn });
  const endDate = endOfWeek(endOfMonth(date), { weekStartsOn });
  return {
    startDate,
    endDate,
    totalDays: 42,
  };
}
/*
 *
 */
export function calculateWeekRange(date, weekStartsOn = 1) {
  const startDate = startOfWeek(date, { weekStartsOn });
  const endDate = endOfWeek(date, { weekStartsOn });
  return {
    startDate,
    endDate,
    totalDays: 7,
  };
}
export class EventNode {
  constructor(event) {
    this.width = 1;
    this.event = event;
  }
}
export class EventBucket {
  constructor() {
    _EventBucket_instances.add(this);
    this.eventNodes = [];
  }
  insert(node) {
    this.eventNodes.push(node);
  }
  process() {
    this.columns = [];
    let events = this.eventNodes.sort((a, b) => {
      return differenceInMilliseconds(a.event.start, b.event.start) || b.event.length() - a.event.length();
    });
    let oldLength = null;
    /* Bucketing */
    while (events.length) {
      if (oldLength == events.length)
        throw new Error('Events not processed in previous run, breaking infinite loop');
      oldLength = events.length;
      const column = [];
      for (let i = 0; i < events.length; i++) {
        if (i == 0)
          column.push(events[i]);
        else if (differenceInMilliseconds(events[i].event.start, column[column.length - 1].event.end) >= 0) {
          column.push(events[i]);
        }
      }
      this.columns.push(column);
      events = events.filter((e) => {
        return !column.find((ce) => {
          return ce.event == e.event;
        });
      });
    }
    for (let i = 0; i < this.columns.length - 1; i++) {
      this.columns[i].forEach((event) => {
        for (let j = i + 1; j < this.columns.length; j++) {
          if (this.columns[j].find((colEvent) => {
            return __classPrivateFieldGet(this, _EventBucket_instances, "m", _EventBucket_eventOverlapping).call(this, event.event, colEvent.event);
          })) {
            break;
          }
          event.width++;
        }
      });
    }
  }
}
_EventBucket_instances = new WeakSet(), _EventBucket_eventOverlapping = function _EventBucket_eventOverlapping(eventA, eventB) {
  if (differenceInMilliseconds(eventA.start, eventB.start) > 0) {
    const temp = eventA;
    eventA = eventB;
    eventB = temp;
  }
  const totalLength = differenceInMilliseconds(eventB.end, eventA.start);
  return totalLength < eventA.length() + eventB.length();
};
//# sourceMappingURL=utils.js.map
